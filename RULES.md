# Правила работы и стиль кода

## Общие правила разработки

- Все изменения должны проходить через code review
- Коммиты должны быть атомарными и содержать понятные сообщения
- Перед коммитом код должен проходить линтер и тесты
- Используем семантическое версионирование (SemVer)

## Стиль кода

- Используем ESLint с конфигурацией Airbnb
- Отступы: 2 пробела
- Используем одинарные кавычки для строк
- Точка с запятой обязательна
- Максимальная длина строки: 100 символов

## Именование

- Переменные и функции: camelCase (например: getUserById, userId)
- Константы: UPPER_SNAKE_CASE (например: MAX_FILE_SIZE, API_BASE_URL)
- Классы: PascalCase (например: UserService, DatabaseConnection)
- Файлы: kebab-case (например: user-service.js, database-connection.js)
- База данных: snake_case для таблиц и колонок (не применимо для фронтенд проекта)

## Структура проекта

### Организация файлов
- Основной код в директории `src/`
- Компоненты группируются по функциональности в подпапках
- Утилиты в `src/utils/`
- Ресурсы (изображения, стили) в `assets/` и `styles/`

### Пример структуры:
```
src/
├── camera/           # Компоненты работы с камерой
├── mediapipe/        # Интеграция с MediaPipe
├── tracking/         # Логика отслеживания головы
├── viewport/         # Управление viewport
├── renderer/         # Рендеринг
├── ui/               # UI компоненты
└── utils/            # Утилиты
```

### Импорты
- Используем ES6 модули (import/export)
- Относительные пути для внутренних модулей
- Абсолютные пути через алиасы (если настроено)

## Работа с Git

### Названия веток
- `feature/название-функции` - для новой функциональности
- `fix/название-бага` - для исправления багов
- `hotfix/название` - для срочных исправлений
- `docs/название` - для изменений в документации
- `refactor/название` - для рефакторинга

### Формат коммитов: Conventional Commits
- `feat: новая функция`
- `fix: исправление бага`
- `docs: изменения в документации`
- `refactor: рефакторинг кода`
- `test: добавление тестов`
- `perf: улучшение производительности`
- `chore: обновление зависимостей, конфигурации`

Примеры:
- `feat: add MediaPipe Face Landmarker integration`
- `fix: correct angular size calculation formula`
- `docs: update README with setup instructions`
- `refactor: extract head tracking logic to separate module`

## Обработка ошибок

- Всегда используем try-catch для асинхронных операций
- Создаем кастомные классы ошибок для специфичных случаев:
  - `CameraAccessError` - ошибка доступа к камере
  - `MediaPipeInitError` - ошибка инициализации MediaPipe
  - `FaceNotFoundError` - лицо не обнаружено в кадре
- Всегда логируем ошибки перед обработкой
- Не передаем детали внутренних ошибок пользователю (только понятные сообщения)
- Для веб-приложения используем console.error для логирования ошибок

### Пример обработки ошибок:
```javascript
try {
  await initializeCamera();
} catch (error) {
  if (error.name === 'NotAllowedError') {
    showUserMessage('Доступ к камере запрещён. Разрешите доступ в настройках браузера.');
  } else {
    console.error('Camera initialization error:', error);
    showUserMessage('Не удалось инициализировать камеру.');
  }
}
```

## Логирование

### Правила логирования
- Используем `console.log` для информационных сообщений (только в режиме разработки)
- Используем `console.error` для ошибок
- Используем `console.warn` для предупреждений
- Используем `console.debug` для отладочной информации
- Не логируем чувствительные данные
- В production режиме отключаем debug логи

### Уровни логирования
- `error` - критические ошибки, требующие внимания
- `warn` - предупреждения о потенциальных проблемах
- `info` - информационные сообщения (инициализация, важные события)
- `debug` - детальная отладочная информация (только в dev режиме)

### Пример:
```javascript
console.info('MediaPipe Face Landmarker initialized');
console.warn('Face not detected in current frame');
console.error('Failed to process video frame:', error);
```

## Тестирование

### Подход к тестированию
- Покрываем тестами критичную бизнес-логику (математические расчёты, преобразования)
- Модульные тесты для утилит и чистых функций
- Интеграционные тесты для компонентов где возможно
- Используем jest или аналогичный фреймворк

### Что тестируем:
- Математические функции (расчёт УРЭ, маппинг РМ → % ФИ)
- Преобразование координат (translation X/Y/Z → viewport)
- Ограничения границ viewport
- Валидация входных данных

### Что НЕ тестируем напрямую (мокируем):
- MediaPipe API (используем моки)
- WebRTC API (используем моки)
- Canvas API (используем моки)

## Безопасность

### Работа с камерой
- Запрашиваем доступ к камере только при необходимости
- Не сохраняем видео-поток локально без явного согласия пользователя
- Обрабатываем случаи, когда пользователь отклоняет доступ к камере

### Веб-безопасность
- Не используем `eval()` или подобные опасные функции (обсудим при необходимости)
- Валидируем все входные данные
- Не загружаем ресурсы с непроверенных источников
- Используем HTTPS для production (обязательно для доступа к камере)

### Зависимости
- Регулярно обновляем зависимости для исправления уязвимостей
- Проверяем безопасность новых зависимостей перед добавлением

## Документация кода


### JSDoc комментарии
- Используем JSDoc для документирования всех функций, классов, методов
- Каждая функция должна иметь описание, параметры (@param) и возвращаемое значение (@returns)
- Документируем сложную бизнес-логику дополнительными комментариями
- Подробно комментируем взаимодействие с MediaPipe - как для новичка
- Обновляем README при изменении API или структуры проекта

### Пример JSDoc:
```javascript
/**
 * Рассчитывает угловой размер экрана по горизонтали
 * @param {number} screenWidth - Ширина экрана в пикселях
 * @param {number} distanceToMonitor - Расстояние от пользователя до монитора (РМ) в метрах
 * @returns {number} Угловой размер экрана в градусах
 */
function calculateAngularSize(screenWidth, distanceToMonitor) {
  return 2 * Math.atan(screenWidth / (2 * distanceToMonitor)) * (180 / Math.PI);
}
```

### Версионирование в коде
- Semver PATCH инкрементируется после каждого раунда "Автор запросил - Cursor ответил"
- Версия и билд (формат: yyyy-mm-dd hh.mm.ss) выводятся в статус-баре приложения (внизу экрана)
- Версия хранится в отдельном файле `src/utils/version.js`

## Зависимости

### Управление зависимостями
- Используем package.json для управления зависимостями
- Фиксируем версии в package-lock.json
- Регулярно обновляем зависимости для безопасности
- Не добавляем зависимости без необходимости
- Проверяем размер библиотек (особенно важно для веб-приложения)

### Критерии добавления зависимости
- Зависимость решает конкретную проблему, которую сложно решить нативно
- Размер библиотеки оправдан её функциональностью
- Библиотека активно поддерживается и безопасна
- Нет альтернатив в нативных Web APIs

### Работа с MediaPipe
- Используем официальные пакеты от Google
- Следим за обновлениями API MediaPipe
- Документируем используемые версии

## Ограничения и запреты

### Что нельзя делать:
- Не использовать синхронные операции для I/O (кроме инициализации)
- Не хранить секреты в коде (используем переменные окружения если понадобится)
- Не коммитить .env файлы
- Не использовать `eval()` или подобные опасные функции - обсудим при необходимости
- Не делать прямые SQL запросы без параметризации (не применимо для фронтенд проекта)
- Не логировать пароли или токены
- Не блокировать главный поток браузера долгими вычислениями (используем Web Workers если нужно)
- Не хранить большие массивы данных в памяти без необходимости

### Специфичные для проекта:
- Не обрабатывать видео-кадры синхронно (используем requestAnimationFrame)
- Не создавать утечки памяти при работе с MediaPipe (правильно освобождаем ресурсы)
- Не блокировать UI при инициализации MediaPipe (показываем индикатор загрузки)
